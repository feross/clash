Feross Todo:

- If pipeline has one or more built-ins and one or more commands, just run the commands
- File path star expansion



Other stuff:
Re: problem with call stack as state w/ incomplete commands - just decompose out the functionality
that allows scanning for end characters, then force full command to be given when constructing job.
(so "> " prints handled before even try to construct job)
-> Moreover, tested this behavior with bash & that's what bash seems to maybe do (at least, it doesn't
run even completed `commands` until the full command has been received)

-> Instead, just throw if fail during parsing.  This requires a change to how we run inline commands, however, and the command class in particular

TODO: change commands class & job-parser to have job-parser not run `commands` when seen, and instead put them into the command.  Then the command will have to, when run, run this command, and invoke job-parser to parse out again... and actually, this won't totally work b/c we might change the command we're parsing into multiple commands, which affect how later things in the
->BUT actually NVM, because it looks like shell doesn't actually "reparse from scratch" at all, it just interprets the output as literal words, and nothing else.  So just needs to parse for words, if appropriate... unfortunately, this means we'd have to introduce some means to track whether we're in quotes, maybe... (because our call stack, which we used to track whether we were in quotes & similar things, is gone at this point)
-> for now, redirect output into path is fine, just assume doesn't change filesystem in some non-repeatable way



Incorrect spec:
 While scanning for the terminating backquote character, no substitutions are performed except that "\`" is replaced with "`"

bash on both versions I tested allows
echo `\\` to be treated as a complete command, even though spec says that first \ will be treated as literal on the first pass (and therefore the second one should be escaped, but isn't)

Moreover, the two versions of bash produce different output in these cases...


"reparsed from scratch" is also a lie
echo `echo '$PATH'` should output the content of variable path if that was true,
instead it outputs $PATH exactly



// 3/12 7pm remaining things to implement:

- initialize variables on start, including special variables like $#, $0, etc.
- move command substitutions to be inside "commands" - meaning commands will
have a way to store arbitrary number of jobs + where the words should be inserted, which
could be inside of a word
---> additionally, we need some method to parse words (& *-style expansions) only, from the output of these commands.  Decompose out from Job Parser, probably
----> this ALSO applies to output from variables
- path expansions in general, i.e. *,?,[]
- exit status
- more error handling in general
- cleanup around job_parser, and handling a few edge cases better/more elegantly if possible.
---> A few particular errors in job-parser (e.g. endline in |, several easy ways to fix but may add state or redundant code...)



Specific argument re: | issue:
At final end of line, if we had a previous job... we CAN'T know if it .... wait
WRONG: we can.  If the previous command ENDED, it will have pushed itself onto the stack.  The only way it could have ended are | and ;.  If it was ;, then we wouldn't be in the same pipeline.  Therefore, if we are an empty command & in this same pipeline, we require more input.



ALTERNATE IDEA I LIKE re: not executing commands multiple times.
JUST HAVE A "CAN PARSE" method that checks if we can parse, and actually just
calls the existing function with a bool that indicates whether we should
try to run inner commands or not.  If we successfully parse the full thing,
then we return true & they'll run the command.  Else we throw to outer method,
which will catch & return false.
This way, only runs at end, because we force them to give us a complete command.
AND can still work this into exposing a single function

And actually, running inner commands IS part of parsing BECAUSE we parse the outputs
from those commands
(issues:
- inner commands may not be valid... but we can actually solve this using the
same idea - if we're "can parse"-ing, we just "can-parse" check the inner job
- both inner commands & outer commands have to be valid, but then they can "interact" in final output,
resulting in maybe incorrect behavior (two valid commands may combine to an invalid command?)
->>> solution exists here too: before running, do command replacements, and check for valid
syntax of full output (CanParse again), if no longer valid we KNOW was command substitution fault,
so can throw the appropriate error & prepend with "command substitution:")

This results in slightly different behavior, but technically matches
the space and results in MUCH cleaner code IMO.
(I found that trying to do the 'track which words to inject on, then go back & inject them' really
broke the whole decomp we had re: scanning the words)


